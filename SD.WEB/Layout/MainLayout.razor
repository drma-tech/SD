@using System.Security.Claims
@using SD.WEB.Core.Auth
@using SD.WEB.Modules.Auth.Core
@using SD.WEB.Modules.Subscription.Core
@using Microsoft.AspNetCore.Components.Authorization
@using Microsoft.JSInterop
@using Toolbelt.Blazor.PWA.Updater
@inherits LayoutComponentBase

@inject ISnackbar Snackbar
@inject IDialogService DialogService
@inject ILogger<MainLayout> Logger
@inject IJSRuntime JsRuntime
@inject AuthenticationStateProvider AuthStateProvider

@inject PrincipalApi PrincipalApi
@inject NavigationManager Navigation
@inject IpInfoApi IpInfoApi
@inject IpInfoServerApi IpInfoServerApi
@inject LoginApi LoginApi

<MudThemeProvider @ref="_mudThemeProvider" IsDarkMode="@_darkMode" />
<MudPopoverProvider />
<MudDialogProvider />
<MudMessageBox />
<MudSnackbarProvider Style="top: 60px;" />

<PWAUpdater Text="@GlobalTranslations.PWAUpdaterText" ButtonCaption="@GlobalTranslations.PWAUpdaterButton" />

<CascadingValue Value="Principal">
    <MudLayout>
        <HeadLayout></HeadLayout>
        <MudMainContent>
            <MudContainer MaxWidth="MaxWidth.ExtraLarge" Class="@Css.Build().Medium("my")" Style="min-height: calc(100vh - 64px - 32px);">
                @Body
            </MudContainer>
            <FooterComponent></FooterComponent>
            <MudDivider Class="@Css.Build().Small("my").Large("mt")"></MudDivider>
            <MudText Align="Align.Center" Class="@Css.Build().Small("mb")">
                © 2021-@DateTime.Now.Year - DRMA Tech.
            </MudText>
        </MudMainContent>
    </MudLayout>
</CascadingValue>

@code {
    private MudThemeProvider? _mudThemeProvider;
    private bool _darkMode = false;
    private AuthPrincipal? Principal { get; set; }

    protected override void OnInitialized()
    {
        try
        {
            // *************************************
            // attention: avoid using asynchronous calls here, as it may affect static html generation (especially for anonymous users)
            // *************************************

            AppStateStatic.DarkModeChanged += dark => { _darkMode = dark; StateHasChanged(); };
            AppStateStatic.ShowError += msg => { Snackbar.Add(msg, Severity.Error); };
            AppStateStatic.BreakpointChanged += breakpoint => StateHasChanged();
            AppStateStatic.BrowserWindowSizeChanged += size => StateHasChanged();
            PrincipalApi.DataChanged += principal => { Principal = principal; StateHasChanged(); };

            // 1 = capture the claims
            AppStateStatic.FirebaseAuthChanged = (string? token) =>
            {
                var provider = (CompositeAuthStateProvider)AuthStateProvider;
                provider.OnFirebaseAuthChanged(token);
            };

            AppStateStatic.SupabaseAuthChanged = (string? token) =>
            {
                var provider = (CompositeAuthStateProvider)AuthStateProvider;
                provider.OnSupabaseAuthChanged(token);
            };

            // 2 = transform claims into useful data
            AuthStateProvider.AuthenticationStateChanged += async (task) =>
            {
                try
                {
                    var state = await task;
                    var user = state.User;

                    AppStateStatic.User = user;
                    AppStateStatic.UserId = user?.FindFirst(c => c.Type == ClaimTypes.NameIdentifier)?.Value;
                    var authenticated = user?.Identity is not null && user.Identity.IsAuthenticated;

                    if (authenticated == AppStateStatic.IsAuthenticated) return; //no need to process if the authentication state didn't change

                    AppStateStatic.IsAuthenticated = authenticated;
                    if (!AppStateStatic.IsAuthenticated) AppStateStatic.IsPremiumUser = false;

                    //principal to be used for all the app
                    if (AppStateStatic.IsAuthenticated)
                        Principal ??= await PrincipalApi.Get(true);
                    else
                        Principal = null;
                    var sub = Principal?.GetActiveSubscription();
                    AppStateStatic.IsPremiumUser = sub?.IsActive() ?? false;
                    AppStateStatic.ActiveProduct = sub?.Product ?? AccountProduct.Basic;

                    await ProcessUserAccess();

                    StateHasChanged();
                    AppStateStatic.UserStateChanged?.Invoke();
                }
                catch (Exception ex)
                {
                    ex.ProcessException(Snackbar, Logger);
                }
            };
        }
        catch (Exception ex)
        {
            ex.ProcessException(Snackbar, Logger);
        }
    }

    /// <summary>
    /// Do not process anything here related to authenticated users. (use UserStateChanged instead)
    /// </summary>
    /// <param name="firstRender"></param>
    /// <returns></returns>
    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        await base.OnAfterRenderAsync(firstRender);

        if (firstRender)
        {
            try
            {
                await ApplyDarkMode();
                await RedirectToRequestConsentForChina();
                await AskUSerForReview();
                await RegisterSessionAccesses();
                await ShowOnBoardingPopup();
            }
            catch (Exception ex)
            {
                ex.ProcessException(Snackbar, Logger);
            }
        }
    }

    private async Task ProcessUserAccess()
    {
        try
        {
            //register new user or new login (need to be last step on this method)
            if (!AppStateStatic.IsAuthenticated) return;
            if (Navigation.Uri.Contains("/support/")) return;

            if (Principal == null)
            {
                Navigation.NavigateTo("/register-user");
            }
            else
            {
                await RegisterLogin();
            }
        }
        catch (Exception ex)
        {
            ex.ProcessException(Snackbar, Logger);
        }
    }

    private async Task RegisterLogin()
    {
        var minInterval = TimeSpan.FromHours(1);
        var now = DateTimeOffset.UtcNow;

        if (AppStateStatic.LastAccess != null && now - AppStateStatic.LastAccess < minInterval)
        {
            return;
        }

        var platform = await AppStateStatic.GetPlatform(JsRuntime);

        await LoginApi.Add(platform);

        AppStateStatic.LastAccess = now;

        if (Principal!.AuthProviders.Empty() || !Principal!.AuthProviders.Contains(AppStateStatic.User!.FindFirst("idp")!.Value)) //if its a new auth provider
        {
            Principal.AuthProviders = Principal.AuthProviders.Union([AppStateStatic.User!.FindFirst("idp")!.Value]).ToArray();
            await PrincipalApi.Update(Principal);
        }
    }

    private async Task ApplyDarkMode()
    {
        var darkMode = await AppStateStatic.GetDarkMode(JsRuntime);

        if (darkMode == null && _mudThemeProvider != null)
        {
            var system = await _mudThemeProvider.GetSystemDarkModeAsync();
            darkMode = system;

            await JsRuntime.Utils().SetStorage("dark-mode", darkMode ?? false);
        }

        AppStateStatic.ChangeDarkMode(darkMode ?? false);
    }

    private async Task RedirectToRequestConsentForChina()
    {
        if (!AppStateStatic.IsAuthenticated && !Navigation.Uri.Contains("/support/"))
        {
            var country = await AppStateStatic.GetCountry(IpInfoApi, IpInfoServerApi, JsRuntime);

            //If you can't identify the country, it's probably in a blocked region (like China). Therefore, we force the user to approve consent.
            if (country.Empty() || country.ToUpper() == "CN")
            {
                var consent = await JsRuntime.Utils().GetStorage<bool>("consent");

                if (!consent)
                {
                    Navigation.NavigateTo("/ask-consent");
                }
            }
        }
    }

    private async Task AskUSerForReview()
    {
        var accesses = await JsRuntime.Utils().GetStorage<HashSet<DateTime>>("session-accesses") ?? new HashSet<DateTime>();
        var hasPreviousAccess = accesses.Count > 0;
        var lastAccess = hasPreviousAccess ? accesses.Max() : (DateTime?)null;
        bool isTooSoon = false;

        if (lastAccess != null)
        {
            var hoursSinceLast = (DateTime.UtcNow - lastAccess.Value).TotalHours;
            isTooSoon = hoursSinceLast < 24;
        }

        var reviewed = await JsRuntime.Utils().GetStorage<bool>("store-reviewed");

        //ask for app store review if ratings are 4 or 5 stars
        if (accesses.Count >= 2 && !reviewed && !isTooSoon)
        {
            _ = Task.Run(async () =>
            {
                await Task.Delay(5000); //delay of 5 seconds
                await DialogService.AskReviewPopup();
            });
        }
    }

    private async Task RegisterSessionAccesses()
    {
        var accesses = await JsRuntime.Utils().GetStorage<HashSet<DateTime>>("session-accesses") ?? new HashSet<DateTime>();
        var hasPreviousAccess = accesses.Count > 0;
        var lastAccess = hasPreviousAccess ? accesses.Max() : (DateTime?)null;
        bool isTooSoon = false;

        if (lastAccess != null)
        {
            var hoursSinceLast = (DateTime.UtcNow - lastAccess.Value).TotalHours;
            isTooSoon = hoursSinceLast < 2;
        }

        if (!isTooSoon)
        {
            accesses.Add(DateTime.UtcNow);

            if (accesses.Count > 10) //keep only the last 10 records
            {
                accesses = accesses.OrderByDescending(x => x).Take(10).ToHashSet();
            }

            await JsRuntime.Utils().SetStorage("session-accesses", accesses);
        }
    }

    private async Task ShowOnBoardingPopup()
    {
        if (Navigation.Uri.Contains("printscreen"))
        {
            return;
        }

        var onboarding = await JsRuntime.Utils().GetStorage<bool>("onboarding-popup");

        //show only once
        if (!onboarding)
        {
            await DialogService.OnboardingPopup();
            await JsRuntime.Utils().SetStorage("onboarding-popup", true);
        }
    }

    [JSInvokable]
    public static void RegistrationSuccessful()
    {
        AppStateStatic.RegistrationSuccessful?.Invoke();
    }

    [JSInvokable]
    public static void AppleVerify(string receipt)
    {
        AppStateStatic.AppleVerify?.Invoke(receipt);
    }

    [JSInvokable]
    public static void ShowError(string error)
    {
        AppStateStatic.ShowError?.Invoke(error);
    }

    [JSInvokable]
    public static void FirebaseAuthChanged(string? token)
    {
        AppStateStatic.FirebaseAuthChanged!.Invoke(token);
    }

    [JSInvokable]
    public static void SupabaseAuthChanged(string? token)
    {
        AppStateStatic.SupabaseAuthChanged!.Invoke(token);
    }

}
